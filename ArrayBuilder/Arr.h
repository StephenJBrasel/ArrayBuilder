#pragma once

#include <stdexcept>

/////////////////////////////////////////////////////////////////////////////
// provides a C++ style array with a size variable.
/////////////////////////////////////////////////////////////////////////////
template <typename T>
class Arr 
{
	T * arr;
	unsigned int Size;

public:

	/////////////////////////////////////////////////////////////////////////////
	// Function :	Constructor
	// Notes : Constructs an empty array of Size _size
	/////////////////////////////////////////////////////////////////////////////
	Arr(unsigned int _size) {
		Size = _size;
		arr = new T[Size];
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function :	Destructor
	// Notes : cleans up any dynamic memory (new)
	/////////////////////////////////////////////////////////////////////////////
	~Arr() {
		delete[] arr;
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function :	Copy Constructor
	/////////////////////////////////////////////////////////////////////////////
	Arr(const Arr<T>& that) {
		arr = nullptr;
		*this = that;
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function :	Assignment Operator
	/////////////////////////////////////////////////////////////////////////////
	Arr<T>& operator=(const Arr<T>& that) {
		if (this != &that) {

			//Clear the original array
			clear();
			this->Size = that.Size;

			arr = new T[Size];
			for (unsigned int i = 0; i < Size; i++) {
				this->arr[i] = that.arr[i];
			}
		}
		return *this;
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function : operator[]
	// Parameters : index - the index to access
	// Return : const T & - returns the array element at [index]
	// Notes : performs no error checking. user should ensure index is 
	//		valid with the size() method
	/////////////////////////////////////////////////////////////////////////////
	const T& operator[](const unsigned int index) const {
		if (index >= Size || index < 0) throw std::out_of_range("index out of range");
		return arr[index];
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function : operator[]
	// Parameters : index - the index to access
	// Return : T & - returns the array element at [index]
	// Notes : performs no error checking. user should ensure index is 
	//		valid with the size() method
	/////////////////////////////////////////////////////////////////////////////
	T& operator[](const unsigned int index) {
		if (index >= Size || index < 0) throw std::out_of_range("index out of range");
		return arr[index];
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function :	size
	// Returns : int - returns the number of items being stored
	// Notes : this function returns the number of items being stored 
	/////////////////////////////////////////////////////////////////////////////
	unsigned int size() const {
		return Size;
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function :	clear
	// Notes : cleans up any dynamic memory and resets Size to 0
	/////////////////////////////////////////////////////////////////////////////
	void clear()
	{
		delete[] arr;
		arr = nullptr;
		Size = 0;
	}

	/////////////////////////////////////////////////////////////////////////////
	// Function :	search
	// Notes :	returns -1 if element not found, 
	//	otherwise index of first element of specified val.
	/////////////////////////////////////////////////////////////////////////////
	int search(const T val) {
		for (unsigned int i = 0; i < size(); i++) {
			if (this->arr[i] == val) return i;
		}
		return -1;
	}
};